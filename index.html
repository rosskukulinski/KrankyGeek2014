<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Scaling WebRTC Audio</title>

	<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
	<meta name="author" content="Hakim El Hattab">

	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<link rel="stylesheet" href="css/reveal.min.css">
	<link rel="stylesheet" href="css/theme/default.css" id="theme">

	<!-- For syntax highlighting -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<section>
				<h1>Scaling WebRTC Audio</h1>
				<h2>for fun and profit</h2>
				<p>
					<small><a href="http://kukulinski.com">Ross Kukulinski</a> / <a href="http://twitter.com/rosskukulinski">@rosskukulinski</a> / 	<a href='http://speakit.io'>SpeakIt.io</a></small>
				</p>
				<aside class="notes">SpeakIt.io is providing a browser-based collaboration environment
					for distributed teams and remote employees.
				</aside>
			</section>


			<section>
				<h2>WebRTC is Peer-to-Peer<span class='fragment'> (usually)</span></h2>
				<h2 class='fragment'>Peer-to-Peer is awesome</h2>
				<h2 class='fragment'>Until it isn't</h2>
				<aside class="notes">
					End to end encryption, decentralization, reduced server load/complexity

				</aside>
			</section>

			<section>
				<h2>Audio Vocabulary 101</h2>
				<ul>
					<li>Transcoding</li>
					<li>Mixing</li>
					<li>Automatic gain control (AGC)</li>
					<li>Acoustic echo cancelation (AEC)</li>
					<li>Recording</li>
				</ul>
			</section>

			<section>
				<h3>Full Meshed Conference</h3>
				<img width="800" height="600" src="img/mesh.JPG" alt="Meshed Conference">
				<aside class="notes">
					Traditional WebRTC p2p conference
					No central server (except for signaling)
					No central point of failure
					Participants can come and go

					Con: More sophisticated endpoints (audio mixing)
				</aside>
			</section>

			<section>
				<h3>Larger Full Meshed Conference</h3>
				<img width="800" height="600" src="img/meshBig.JPG" alt="Meshed Conference">
				<aside class="notes">

				</aside>
			</section>

			<section>
				<h3>Star Mesh Conference: Endpoint as Mixer</h3>
				<img width="800" height="600" src="img/supernode.JPG" alt="SuperNode Conference">
				<aside class="notes">
					Still p2p
				Mixing endpoint (A) can't leave
				As number of participants goes up, A's requirements increases
			   COULD do more complex system with multiple supernodes, but increases
				 client side complexity
				Also, how do you decide which end point is the mixer?
				</aside>
			</section>

			<section>
				<h3>Multi-Star Conference</h3>
				<img width="800" height="600" src="img/supernodeBig.JPG" alt="SuperNode Conference">
				<aside class="notes">
				Scales better, but still how do you decide which end point to be a mixer
				Also: more complex if B wants to mute E.
				</aside>
			</section>


			<section>
				<h3>Multipoint Control Unit (aka 'Media Server')</h3>
				<img width="800" height="600" src="img/mediaserver.JPG" alt="Media Server Conference">
				<aside class="notes">
					Offloads mixing computation
					Reduces bandwidth

					Density important (how many streams can you mix?)

					Con: Central point of failure
				</aside>
			</section>

			<section>
				<h3>Larger MCU</h3>
				<img width="800" height="600" src="img/mediaserverBig.JPG" alt="Media Server Conference">
				<aside class="notes">
					Offloads mixing computation
					Reduces bandwidth

					Density important (how many streams can you mix, transcode?)

					Con: Central point of failure still
				</aside>
			</section>

			<section>
				<h2>Advantages of MCUs</h2>
				<ul>
					<li>Offloads processing from endpoints</li>
					<li>Recording / Transcription</li>
					<li>Re-broadcast (podcasts, live gaming events, etc)</li>
					<li>Sound Effects / Text-to-Speech / Music</li>
				</ul>
			</section>

			<section>
				<h2>SpeakIt Media Cluster</h2>
				<img width="800" height="600" src="img/mediaCluster.JPG" alt="Media Server Conference">
			</section>

			<section>
				<h3>Geolocation</h3>
				<h3>Redundancy / Fault Tolerence</h3>
			</section>



		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

		// Full list of configuration options available here:
		// https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: false,
			progress: false,
			history: true,
			center: true,
			slideNumber: true,

			theme: 'beige', // available themes are in /css/theme
			transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

			// Parallax scrolling
			// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
			// parallaxBackgroundSize: '2100px 900px',

			// Optional libraries used to extend on reveal.js
			dependencies: [
			{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
			{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
			{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
			{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
			]
		});

		</script>

	</body>
	</html>
